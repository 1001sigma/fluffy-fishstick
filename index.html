<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>量子粒子系统 2.0 (GPU加速版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        
        /* 3D 容器 */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* 摄像头画中画 */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 120px; height: 90px;
            border-radius: 12px; border: 2px solid rgba(255,255,255,0.3);
            object-fit: cover; z-index: 10; transform: scaleX(-1); /* 镜像 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: #000;
            opacity: 0.8;
            pointer-events: none;
        }

        /* 新增：头部布局 */
.panel-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer; /* 允许点击标题折叠 */
    margin-bottom: 10px;
}

/* 新增：折叠按钮样式 */
#minimize-btn {
    background: transparent;
    border: 1px solid rgba(0,255,255,0.3);
    color: #00ffff;
    width: 24px; height: 24px;
    padding: 0;
    line-height: 20px;
    font-size: 16px;
    border-radius: 50%;
    margin-left: 10px;
}
#minimize-btn:hover {
    background: rgba(0,255,255,0.2);
}

/* 新增：内容区域动画 */
#panel-content {
    max-height: 500px; /* 给一个足够大的高度 */
    opacity: 1;
    overflow: hidden;
    transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
}

/* 新增：最小化状态 */
#ui-panel.minimized #panel-content {
    max-height: 0;
    opacity: 0;
    margin: 0;
}

#ui-panel.minimized {
    background: rgba(10, 10, 20, 0.4); /* 折叠后背景变淡 */
    width: auto; /* 宽度自适应 */
    min-width: 200px;
}
        /* UI 面板 */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 260px;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(12px);
            padding: 20px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            color: white; z-index: 10;
            user-select: none;
            transition: opacity 0.3s;
            max-height: 90vh;
            overflow-y: auto;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; letter-spacing: 1px; color: #00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5); text-transform: uppercase; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 11px; margin-bottom: 6px; color: #889; text-transform: uppercase;}
        
        /* 自定义滑块 */
        input[type="range"] {
            width: 100%; -webkit-appearance: none; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; background: #00ffff; border-radius: 50%; cursor: pointer; border: 2px solid #000;
        }

        /* 按钮组 */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            color: #ddd; padding: 8px; border-radius: 6px; cursor: pointer;
            transition: all 0.2s; font-size: 12px;
        }
        button:hover { background: rgba(0,255,255,0.1); border-color: #00ffff; color: #fff;}
        button.active { background: #00ffff; color: #000; font-weight: bold; box-shadow: 0 0 10px rgba(0,255,255,0.4);}

        /* 颜色选择器 */
        .color-wrapper { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;}
        input[type="color"] { border: none; width: 40px; height: 25px; cursor: pointer; background: none; }

        /* 绘图层 */
        #draw-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; cursor: crosshair; display: none; touch-action: none;
        }
        
        .status { font-size: 10px; color: #aaa; margin-top: 10px; display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;}
        .dot { width: 8px; height: 8px; background: #555; border-radius: 50%; display: inline-block; transition: background 0.3s;}
        .dot.active { background: #00ff00; box-shadow: 0 0 5px #00ff00; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 16px; z-index: 100; pointer-events: none;
            text-shadow: 0 0 10px #00ffff; letter-spacing: 2px; text-align: center;
        }
        
        /* 移动端适配 */
        @media (max-width: 600px) {
            #ui-panel { width: calc(100% - 40px); bottom: 20px; top: auto; max-height: 40vh; }
            #video-preview { top: 20px; bottom: auto; width: 80px; height: 60px; }
            h2 { font-size: 14px; margin-bottom: 10px; }
            .btn-grid { grid-template-columns: 1fr 1fr 1fr; gap: 5px; }
        }
    </style>
</head>
<body>

    <div id="loading">SYSTEM INITIALIZING...<br><span style="font-size:12px; opacity:0.7">Loading GPU Kernels & AI Models</span></div>

    <div id="canvas-container"></div>
    
    <canvas id="draw-canvas"></canvas>

    <video id="video-preview" playsinline></video>

    <div id="ui-panel">
    <div class="panel-header" id="panel-header">
        <h2>QUANTUM CORE 2.0</h2>
        <button id="minimize-btn">−</button>
    </div>

    <div id="panel-content">
        <div class="control-group">
            <label>形状预设 (Shape)</label>
            <div class="btn-grid">
                <button onclick="setShape('sphere')" class="active" id="btn-sphere">球体</button>
                <button onclick="setShape('vortex')" id="btn-vortex">星系</button>
                <button onclick="setShape('heart')" id="btn-heart">爱心</button>
                <button onclick="setShape('helix')" id="btn-helix">DNA</button>
                <button onclick="setShape('text')" id="btn-text">文字</button>
                <button onclick="setShape('draw')" id="btn-draw">手绘</button>
            </div>
        </div>

        <div class="color-wrapper">
            <label>核心颜色 (Color)</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>

        <div class="control-group">
            <label>粒子总量 (Count: <span id="count-display">20000</span>)</label>
            <input type="range" id="density" min="5000" max="50000" step="5000" value="20000">
        </div>

        <div class="control-group">
            <label>力场强度 (Force)</label>
            <input type="range" id="spread" min="0.5" max="8.0" step="0.5" value="3.0">
        </div>

        <div class="status">
            <span class="dot" id="hand-status"></span>
            <span id="status-text">等待摄像头信号...</span>
        </div>
    </div>
</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 全局变量 ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let bgParticles;
        
        // 系统状态
        let particleCount = 20000;
        let currentShape = 'sphere';
        let handPos = new THREE.Vector3(999, 999, 999); // 初始位置放远点
        let targetHandPos = new THREE.Vector3(999, 999, 999);
        
        let isHandDetected = false;
        let isHandOpen = false; 
        let handStrength = 0; 
        let baseColor = new THREE.Color(0x00ffff);
        let spreadFactor = 3.0;

        // 绘图相关
        let isDrawing = false;
        let drawPoints = [];
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');
        
        // 文字缓存
        let cachedTextPoints = null;

        // --- 初始化 ---
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比以提升性能
            container.appendChild(renderer.domElement);

            setupParticles();
            setupBackground();
            
            window.addEventListener('resize', onWindowResize, false);
            setupUI();
            setupDrawingInteraction();

            animate();
            
            // 隐藏 Loading
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 1500);
        }

        // --- 核心：GPU 粒子系统 ---
        function setupParticles() {
            if(particles) scene.remove(particles);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const randomness = new Float32Array(particleCount * 3);
            
            for(let i=0; i<particleCount; i++) {
                // 初始位置设为 0，之后由 updateTargetShape 填充
                positions[i*3] = 0;
                positions[i*3+1] = 0;
                positions[i*3+2] = 0;

                randomness[i*3] = Math.random();
                randomness[i*3+1] = Math.random();
                randomness[i*3+2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 3));

            // --- 优化后的 Shader ---
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: baseColor },
                    uHandPos: { value: new THREE.Vector3(0,0,0) },
                    uStrength: { value: 0 },
                    uSpread: { value: spreadFactor }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uStrength;
                    uniform float uSpread;
                    uniform vec3 uHandPos;
                    attribute vec3 randomness;
                    varying float vAlpha;
                    
                    // 简单的伪随机函数
                    float random(vec2 st) {
                        return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                    }
                    
                    void main() {
                        // position 此时存储的是"目标形状"的静态坐标
                        vec3 pos = position;
                        
                        // 1. 基础环境噪点运动 (在 GPU 中计算，零 CPU 消耗)
                        float t = uTime * 0.5;
                        pos.x += sin(t + randomness.y * 6.0) * 0.3;
                        pos.y += cos(t * 0.8 + randomness.x * 6.0) * 0.3;
                        pos.z += sin(t * 0.3 + randomness.z * 6.0) * 0.3;

                        // 2. 手势物理排斥
                        float dist = distance(pos, uHandPos);
                        
                        // 只有当手张开 (uStrength > 0) 且距离够近时才排斥
                        if (uStrength > 0.05) {
                            vec3 dir = normalize(pos - uHandPos);
                            
                            // 物理公式：力与距离平方成反比
                            float force = (uSpread * 15.0) / (dist * dist + 0.5);
                            force = clamp(force, 0.0, 10.0); // 限制最大力度
                            
                            // 混合位置
                            pos += dir * force * uStrength;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        
                        // 粒子大小随深度变化
                        gl_PointSize = (5.0 / -mvPosition.z);
                        
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // 边缘渐隐
                        vAlpha = 1.0 - smoothstep(20.0, 50.0, length(pos));
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vAlpha;
                    
                    void main() {
                        // 圆形粒子裁切
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if (r > 0.5) discard;
                        
                        // 径向辉光
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);

                        gl_FragColor = vec4(uColor, glow * vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            updateTargetShape();
        }

        // --- 形状生成逻辑 ---
        function updateTargetShape() {
            const positions = geometry.attributes.position.array;
            const radius = 12;

            // 辅助：文字坐标生成
            let textCoords = [];
            if(currentShape === 'text') {
                if(!cachedTextPoints) cachedTextPoints = getTextCoordinates("AI"); // 默认文字
                textCoords = cachedTextPoints;
            }

            for(let i=0; i<particleCount; i++) {
                let x, y, z;
                const i3 = i * 3;

                if(currentShape === 'sphere') {
                    // 球体/黑洞
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = radius * Math.cbrt(Math.random()); 
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (currentShape === 'vortex') {
                    // 星系漩涡
                    const angle = i * 0.005 + (Math.random()*0.1);
                    const r = (i / particleCount) * radius * 1.8;
                    x = r * Math.cos(angle * 5.0);
                    y = (Math.random() - 0.5) * (r * 0.2); 
                    z = r * Math.sin(angle * 5.0);
                }
                else if (currentShape === 'heart') {
                    // 爱心 (New)
                    // 参数方程
                    const t = Math.random() * Math.PI * 2;
                    // 原始公式
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    
                    const scale = 0.6;
                    x = hx * scale;
                    y = hy * scale;
                    // 增加 Z 轴厚度
                    z = (Math.random() - 0.5) * 8;
                    
                    // 内部填充随机点
                    if(Math.random() > 0.5) {
                        x *= Math.random();
                        y *= Math.random();
                        z *= Math.random();
                    }
                }
                else if (currentShape === 'helix') {
                    // DNA 双螺旋 (New)
                    const turns = 4; 
                    const height = 25;
                    const h = (Math.random() - 0.5) * height; // -12.5 ~ 12.5
                    const strandOffset = Math.random() > 0.5 ? 0 : Math.PI;
                    const angle = (h / height) * (Math.PI * 2 * turns) + strandOffset;
                    const r = 5;

                    x = Math.cos(angle) * r;
                    y = h;
                    z = Math.sin(angle) * r;

                    // 增加杂乱感
                    x += (Math.random()-0.5);
                    y += (Math.random()-0.5);
                    z += (Math.random()-0.5);
                }
                else if (currentShape === 'text') {
                    // 文字 (New)
                    if (textCoords.length > 0) {
                        const p = textCoords[i % textCoords.length];
                        x = p.x + (Math.random()-0.5)*0.5;
                        y = p.y + (Math.random()-0.5)*0.5;
                        z = (Math.random() - 0.5) * 2;
                    } else {
                        x = (Math.random()-0.5)*10; y=(Math.random()-0.5)*10; z=0;
                    }
                }
                else if (currentShape === 'draw') {
                    // 手绘模式
                    if (drawPoints.length > 0) {
                        const p = drawPoints[i % drawPoints.length];
                        x = p.x + (Math.random()-0.5)*0.5;
                        y = p.y + (Math.random()-0.5)*0.5;
                        z = (Math.random() - 0.5) * 2; // 略微有厚度
                    } else {
                        // 默认圆环
                        const t = Math.random() * Math.PI * 2;
                        x = Math.cos(t) * 8;
                        y = Math.sin(t) * 8;
                        z = 0;
                    }
                }

                // 直接写入 BufferAttribute
                positions[i3] = x;
                positions[i3+1] = y;
                positions[i3+2] = z;
            }

            // 标记通知 GPU 更新
            geometry.attributes.position.needsUpdate = true;
        }

        // --- 辅助：文字转坐标 ---
        function getTextCoordinates(text) {
            const size = 100;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,size,size);
            ctx.fillStyle = '#fff'; ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, size/2, size/2);
            
            const data = ctx.getImageData(0,0,size,size).data;
            const coords = [];
            for(let y=0; y<size; y++) {
                for(let x=0; x<size; x++) {
                    if(data[(y*size+x)*4] > 128) {
                        coords.push({
                            x: (x - size/2) * 0.35,
                            y: -(y - size/2) * 0.35,
                            z: 0
                        });
                    }
                }
            }
            return coords;
        }

        // --- 背景星空 ---
        function setupBackground() {
            const bgGeo = new THREE.BufferGeometry();
            const bgCount = 1000;
            const bgPos = new Float32Array(bgCount * 3);
            for(let i=0; i<bgCount*3; i++) bgPos[i] = (Math.random() - 0.5) * 300;
            bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
            const bgMat = new THREE.PointsMaterial({ color: 0x666666, size: 0.8, transparent: true, opacity: 0.5 });
            bgParticles = new THREE.Points(bgGeo, bgMat);
            scene.add(bgParticles);
        }

        // --- MediaPipe 配置 (优化版) ---
        function setupMediaPipe() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // 0=Lite(快), 1=Full(准). 移动端建议 0
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(document.getElementById('video-preview'), {
                onFrame: async () => { await hands.send({image: document.getElementById('video-preview')}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            const statusDot = document.getElementById('hand-status');
            const statusText = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                statusDot.classList.add('active');
                
                const lm = results.multiHandLandmarks[0];
                
                // 坐标映射：MediaPipe(0~1) -> Three.js 视口坐标
                const x = (0.5 - lm[9].x) * 40; 
                const y = (0.5 - lm[9].y) * 25;
                // 利用手掌宽窄来模拟深度 (简单近似)
                // const z = (lm[0].z) * 10; 暂时不用z，太抖动

                targetHandPos.set(x, y, 0);

                // 手势识别：食指尖与拇指尖距离
                const pinchDist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                
                if (pinchDist > 0.12) {
                    isHandOpen = true;
                    statusText.innerText = "状态: 扩散 (Open)";
                } else {
                    isHandOpen = false;
                    statusText.innerText = "状态: 聚合 (Closed)";
                }
            } else {
                isHandDetected = false;
                statusDot.classList.remove('active');
                statusText.innerText = "未检测到手部";
                targetHandPos.set(999, 999, 999); // 移出屏幕
                isHandOpen = false;
            }
        }

        // --- 绘图与交互 (含 Touch) ---
        function setupDrawingInteraction() {
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;

            function get3DPos(clientX, clientY) {
                const vec = new THREE.Vector3();
                vec.set((clientX / window.innerWidth) * 2 - 1, -(clientY / window.innerHeight) * 2 + 1, 0.5);
                vec.unproject(camera);
                vec.sub(camera.position).normalize();
                const distance = -camera.position.z / vec.z;
                const pos = new THREE.Vector3().copy(camera.position).add(vec.multiplyScalar(distance));
                return pos;
            }

            // 统一处理鼠标和触摸
            const startDraw = (x, y) => {
                isDrawing = true;
                drawPoints = [];
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                drawCtx.beginPath();
                drawCtx.moveTo(x, y);
                drawCtx.strokeStyle = '#00ffff';
                drawCtx.lineWidth = 3;
            };

            const moveDraw = (x, y) => {
                if(!isDrawing) return;
                drawCtx.lineTo(x, y);
                drawCtx.stroke();
                drawPoints.push(get3DPos(x, y));
            };

            const endDraw = () => {
                isDrawing = false;
                updateTargetShape(); // 生成粒子
                toggleDrawMode(false); // 退出绘图模式
                document.getElementById('btn-draw').classList.add('active'); // 保持按钮高亮
            };

            // Mouse Events
            drawCanvas.addEventListener('mousedown', e => startDraw(e.clientX, e.clientY));
            drawCanvas.addEventListener('mousemove', e => moveDraw(e.clientX, e.clientY));
            drawCanvas.addEventListener('mouseup', endDraw);

            // Touch Events (Mobile)
            drawCanvas.addEventListener('touchstart', e => {
                e.preventDefault();
                startDraw(e.touches[0].clientX, e.touches[0].clientY);
            }, {passive: false});
            drawCanvas.addEventListener('touchmove', e => {
                e.preventDefault();
                moveDraw(e.touches[0].clientX, e.touches[0].clientY);
            }, {passive: false});
            drawCanvas.addEventListener('touchend', endDraw);
        }

        // --- UI 逻辑 ---
        function toggleDrawMode(active) {
            const canvas = document.getElementById('draw-canvas');
            const btns = document.querySelectorAll('.btn-grid button');
            btns.forEach(b => b.classList.remove('active'));

            if(active) {
                canvas.style.display = 'block';
                document.getElementById('status-text').innerText = "请在屏幕上绘制图案...";
                currentShape = 'draw';
            } else {
                canvas.style.display = 'none';
            }
        }

        window.setShape = function(shape) {
            currentShape = shape;
            if (shape === 'draw') {
                toggleDrawMode(true);
            } else {
                toggleDrawMode(false);
                document.getElementById(`btn-${shape}`).classList.add('active');
                
                // 如果是 Text 模式，可以弹窗让用户输入
                if(shape === 'text') {
                    const userInput = prompt("请输入要显示的文字 (建议英文, 1-4个字符):", "AI");
                    if(userInput) {
                         cachedTextPoints = getTextCoordinates(userInput);
                    } else {
                        // 用户取消则用默认
                        cachedTextPoints = getTextCoordinates("AI");
                    }
                }
                
                updateTargetShape();
            }
        }

        function setupUI() {
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                baseColor.set(e.target.value);
                if(material) material.uniforms.uColor.value = baseColor;
            });

            document.getElementById('density').addEventListener('change', (e) => {
                particleCount = parseInt(e.target.value);
                document.getElementById('count-display').innerText = particleCount;
                setupParticles(); // 重建系统
            });

            document.getElementById('spread').addEventListener('input', (e) => {
                spreadFactor = parseFloat(e.target.value);
                if(material) material.uniforms.uSpread.value = spreadFactor;
            });

    // --- 新增：最小化逻辑 ---
    const panel = document.getElementById('ui-panel');
    const minBtn = document.getElementById('minimize-btn');
    const header = document.getElementById('panel-header');

    // 切换函数
    function togglePanel() {
        panel.classList.toggle('minimized');
        
        // 更改按钮符号
        if (panel.classList.contains('minimized')) {
            minBtn.innerText = '+';
        } else {
            minBtn.innerText = '−'; // 注意这是减号符号，不是连字符
        }
    }

    // 绑定点击事件 (点击按钮或标题都可以折叠)
    minBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // 防止冒泡
        togglePanel();
    });
    
    header.addEventListener('click', togglePanel);
}
        

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            if (material) {
                material.uniforms.uTime.value = time;
                
                // 平滑插值手部位置 (Smooth Lerp)
                handPos.lerp(targetHandPos, 0.15);
                material.uniforms.uHandPos.value.copy(handPos);

                // 平滑插值手势强度
                let targetStrength = isHandOpen ? 1.0 : 0.0;
                // 如果手移出屏幕，强度归零
                if (!isHandDetected) targetStrength = 0.0;
                
                handStrength += (targetStrength - handStrength) * 0.1;
                material.uniforms.uStrength.value = handStrength;
            }

            // 背景旋转
            if(bgParticles) {
                bgParticles.rotation.y = time * 0.03;
            }

            // 场景随手部位置微动（视差效果）
            // 限制最大旋转角度
            const rotX = -(handPos.y / 100) * 0.2;
            const rotY = (handPos.x / 100) * 0.2;
            
            // 如果手没检测到，慢慢回正
            if(isHandDetected) {
                scene.rotation.x += (rotX - scene.rotation.x) * 0.05;
                scene.rotation.y += (rotY - scene.rotation.y) * 0.05;
            } else {
                scene.rotation.x += (0 - scene.rotation.x) * 0.05;
                scene.rotation.y += (0 - scene.rotation.y) * 0.05;
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;
        }

        // 启动
        init();
        setupMediaPipe();

    </script>
</body>
</html>
