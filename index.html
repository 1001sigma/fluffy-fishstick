<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>WebGL MediaPipe 沉浸式粒子系统</title>
    <style>
        /* 样式：全屏画布，无滚动条 */
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        /* 隐藏 MediaPipe 默认的视频输出，实现“无摄像头画面”要求 */
        #video-container { display: none; }
        /* 自定义提示信息样式 */
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-family: Arial, sans-serif;
            font-size: 14px;
            text-shadow: 0 0 5px #000;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">请允许使用摄像头. (握拳: 聚合 | 张开: 扩散 | 拇指食指捏合: 绘图)</div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    
    <script>
        // ====================================================================
        // === 全局变量定义 ===
        // ====================================================================
        let scene, camera, renderer, clock;
        let particleSystem;
        let backgroundParticles;
        let isDrawing = false; // 是否处于手绘模式
        let drawingMode = false; // dat.GUI控制的绘图开关

        // dat.GUI 控件参数
        const settings = {
            // UI 界面要求
            model: '星云', // 预设粒子模型
            density: 50000, // 粒子密度（最大数量）
            spread: 1.0,   // 粒子扩散度 (控制 Three.js 中的 scale)
            particleColor: '#00ffaa', // 粒子颜色
            // 手势控制 UI 界面要求
            handMode: '单手', // '单手' | '双手'
            // 手绘功能 UI 界面要求
            enableDrawing: false, // 启用手绘模式
            resetCustom: () => resetCustomParticles(), // 重置手绘粒子
            // UI 最小化 (dat.GUI 自带此功能，无需额外编码)
        };

        // MediaPipe 相关
        let hands;
        let video;
        let handOpennessFactor = 0.5; // 0 (握拳) 到 1 (张开)

        // 粒子系统配置
        const MAX_PARTICLES = 100000;
        const PARTICLE_SIZE = 5;

        // 粒子自定义属性 (用于着色器)
        let particlePositions = new Float32Array(MAX_PARTICLES * 3);
        let particleOpacities = new Float32Array(MAX_PARTICLES); // 透明度
        let initialPositions = new Float32Array(MAX_PARTICLES * 3); // 初始位置用于聚合/扩散

        // ====================================================================
        // === 着色器代码 (Shader Code) ===
        // 核心：实现粒子的高性能渲染和扩散/聚合动画
        // ====================================================================

        // 顶点着色器 (Vertex Shader): 控制粒子的位置和大小
        const vertexShader = `
            attribute float pOpacity;       // 粒子的自定义透明度
            uniform float uTime;            // 时间，用于轻微抖动动画
            uniform float uHandOpenness;    // 手部张开因子 (0.0: 聚合, 1.0: 扩散)
            uniform float uParticleSize;    // 粒子基础大小
            uniform float uMaxSpread;       // UI控制的扩散乘数
            attribute vec3 initialPosition; // 粒子的初始位置

            varying vec4 vColor;            // 传递给片元着色器的颜色

            void main() {
                // 1. 扩散/聚合逻辑: 根据手势因子在初始位置和当前位置之间插值
                // 粒子的当前位置
                vec3 currentPos = position; 
                // 初始位置 (模型的形状)
                vec3 initPos = initialPosition;
                
                // 目标位置: 初始位置 + 扩散 (uHandOpenness * uMaxSpread)
                vec3 targetPos = initPos + normalize(initPos) * uHandOpenness * uMaxSpread * 150.0;
                
                // 最终位置: 初始位置向目标位置移动的距离
                vec3 finalPosition = mix(initPos, targetPos, uHandOpenness * uMaxSpread);

                // 2. 增加一点微小抖动，增加动态感
                finalPosition.x += sin(uTime + finalPosition.y * 0.01) * 0.5;
                finalPosition.y += cos(uTime + finalPosition.z * 0.01) * 0.5;
                
                // 3. 计算在屏幕上的最终位置
                vec4 mvPosition = modelViewMatrix * vec4(finalPosition, 1.0);
                gl_PointSize = uParticleSize * (200.0 / -mvPosition.z); // 粒子大小随深度变化

                // 4. 设置顶点颜色 (这里将颜色和透明度传递给片元着色器)
                // 顶点颜色 = Three.js设置的 uniform 颜色 * 自定义透明度
                vColor = vec4(color, pOpacity);

                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // 片元着色器 (Fragment Shader): 控制粒子的颜色和形状 (圆形)
        const fragmentShader = `
            uniform vec3 uParticleColor;    // UI 控制的粒子颜色
            varying vec4 vColor;            // 从顶点着色器接收的颜色 (包含透明度)

            void main() {
                // 计算距离粒子中心的距离
                float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                
                // 如果距离大于 0.5，则丢弃（创建圆形粒子）
                if (r > 0.5) {
                    discard;
                }
                
                // 设置最终颜色：将 UI 颜色与插值后的透明度结合
                gl_FragColor = vec4(uParticleColor, vColor.a * (1.0 - r * 0.8)); // 边缘软化
            }
        `;

        // ====================================================================
        // === Three.js 场景初始化和渲染 ===
        // ====================================================================

        function initThreeJS() {
            clock = new THREE.Clock();

            // 1. 场景
            scene = new THREE.Scene();

            // 2. 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.z = 1000;

            // 3. 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 初始化背景粒子
            initBackgroundParticles();

            // 5. 初始化主粒子系统 (先初始化一个空集合)
            initMainParticleSystem();
            
            // 6. 首次加载默认模型
            loadPresetModel(settings.model);

            // 7. 事件监听
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function initBackgroundParticles() {
            const numBgParticles = 500;
            const bgGeometry = new THREE.BufferGeometry();
            const bgPositions = new Float32Array(numBgParticles * 3);
            const bgSizes = new Float32Array(numBgParticles);

            for (let i = 0; i < numBgParticles; i++) {
                // 随机分布在深空，形成空间纵深感
                const radius = Math.random() * 2000 + 500;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                bgPositions[i * 3 + 0] = radius * Math.sin(phi) * Math.cos(theta);
                bgPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                bgPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                bgSizes[i] = Math.random() * 3 + 1; // 星星大小变化
            }

            bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
            bgGeometry.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
            
            const bgMaterial = new THREE.PointsMaterial({
                color: 0xaaaaaa,
                size: 2,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.7
            });

            backgroundParticles = new THREE.Points(bgGeometry, bgMaterial);
            scene.add(backgroundParticles);
        }

        function initMainParticleSystem() {
            // 粒子几何体
            const geometry = new THREE.BufferGeometry();
            
            // 粒子自定义属性 (Attribute): 必须在 BufferGeometry 上设置
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('initialPosition', new THREE.BufferAttribute(initialPositions, 3));
            geometry.setAttribute('pOpacity', new THREE.BufferAttribute(particleOpacities, 1));
            
            // 粒子着色器材质
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0.0 },
                    uHandOpenness: { value: settings.handOpennessFactor },
                    uParticleSize: { value: PARTICLE_SIZE },
                    uMaxSpread: { value: settings.spread },
                    uParticleColor: { value: new THREE.Color(settings.particleColor) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending, // 增加发光效果
                depthTest: false, // 关闭深度测试，确保粒子始终可见
            });
            
            // 创建粒子系统
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // 初始设置为0个粒子
            updateParticleCount(0);
        }

        function updateParticleCount(count) {
            count = Math.min(count, MAX_PARTICLES);
            
            // 仅更新可见粒子的数量，Three.js 会自动处理 Buffer
            particleSystem.geometry.setDrawRange(0, count);
            
            // 更新 UI 中的粒子密度滑块，确保它反映当前实际数量
            settings.density = count;
            // dat.GUI 会在下次更新时自动刷新
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();
            
            // 1. 更新着色器 Uniforms
            if (particleSystem) {
                const material = particleSystem.material;
                material.uniforms.uTime.value = elapsed;
                
                // 平滑过渡 handOpennessFactor，防止手势变化过于突兀
                handOpennessFactor = THREE.MathUtils.lerp(handOpennessFactor, getHandOpenness(), 0.1);
                material.uniforms.uHandOpenness.value = handOpennessFactor;
                
                // 实时更新扩散度
                material.uniforms.uMaxSpread.value = settings.spread;

                // 实时更新颜色 (如果颜色发生变化)
                if (material.uniforms.uParticleColor.value.getHexString() !== settings.particleColor.substring(1)) {
                     material.uniforms.uParticleColor.value.set(settings.particleColor);
                }
            }
            
            // 2. 背景粒子轻微旋转
            backgroundParticles.rotation.y += delta * 0.005;

            // 3. 主粒子系统轻微旋转
            particleSystem.rotation.y += delta * 0.01;
            particleSystem.rotation.x += delta * 0.005;

            renderer.render(scene, camera);
        }

        // ====================================================================
        // === MediaPipe 手势处理 ===
        // ====================================================================

        function initMediaPipe() {
            video = document.createElement('video');
            document.body.appendChild(video); // 视频元素虽然隐藏，但必须存在

            hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1, // 增加复杂性以提高精度
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);

            // 启动摄像头
            const cameraCapture = new Camera(video, {
                onFrame: async () => {
                    await hands.send({image: video});
                },
                width: 640,
                height: 480
            });
            cameraCapture.start();
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                processHandGestures(results.multiHandLandmarks);
            } else {
                // 没有手部检测到时，粒子系统逐渐恢复到中间状态
                currentHandOpenness = 0.5;
            }
        }
        
        // 用于存储 MediaPipe 计算的当前手部张开因子
        let currentHandOpenness = 0.5; 
        
        function getHandOpenness() {
            // 提供给 Three.js 的函数
            return currentHandOpenness;
        }

        function processHandGestures(landmarksArray) {
            let opennessSum = 0;
            
            // 检查绘图模式：任一只手拇指 (4) 和食指 (8) 捏合
            isDrawing = landmarksArray.some(landmarks => {
                const thumbTip = new THREE.Vector3().fromArray(landmarks[4]);
                const indexTip = new THREE.Vector3().fromArray(landmarks[8]);
                return thumbTip.distanceTo(indexTip) < 0.05; // 欧式距离小于阈值
            });

            if (settings.enableDrawing && isDrawing) {
                // 如果开启了手绘功能并且手势为捏合
                const handCenter = landmarksArray[0][9]; // 取第一只手的掌心
                addCustomParticle(handCenter);
                currentHandOpenness = 0.5; // 绘图时保持中立
                return;
            }

            // 正常聚合/扩散逻辑
            landmarksArray.forEach(landmarks => {
                // 掌心 (9) 和 腕部 (0)
                const center = new THREE.Vector3().fromArray(landmarks[9]);
                const wrist = new THREE.Vector3().fromArray(landmarks[0]);
                const handDepth = center.distanceTo(wrist); // 估算手的大小/深度

                let fingerDistanceSum = 0;
                // 检测四指：食指 (8), 中指 (12), 无名指 (16), 小指 (20)
                const fingerTips = [8, 12, 16, 20];

                fingerTips.forEach(tipIndex => {
                    const tip = new THREE.Vector3().fromArray(landmarks[tipIndex]);
                    // 计算指尖到掌心的距离
                    fingerDistanceSum += tip.distanceTo(center);
                });
                
                // 估算开放程度 (归一化): 距离总和 / 理论最大距离
                // 握拳时距离总和最小，张开时最大。
                const minDistance = handDepth * 1.5; // 估算握拳时的最小距离
                const maxDistance = handDepth * 4.0; // 估算张开时的最大距离
                
                let openness = (fingerDistanceSum - minDistance) / (maxDistance - minDistance);
                openness = THREE.MathUtils.clamp(openness, 0.0, 1.0);
                
                opennessSum += openness;
            });
            
            // 单手/双手逻辑处理
            if (settings.handMode === '单手' && landmarksArray.length > 0) {
                 // 使用第一只手的开放度
                 currentHandOpenness = opennessSum / landmarksArray.length;
            } else if (settings.handMode === '双手' && landmarksArray.length === 2) {
                // 双手设计：平均开放度
                 currentHandOpenness = opennessSum / 2;
            } else {
                // 未满足模式条件时，保持中立
                currentHandOpenness = 0.5; 
            }
        }


        // ====================================================================
        // === 粒子模型和手绘功能 ===
        // ====================================================================
        
        // 预设模型数据: { name: '...', func: (count) => [x, y, z] 数组 }
        const PRESET_MODELS = {
            '星云': (count) => generateNebula(count, 500),
            '星座（射手座）': (count) => generateConstellation(count, 'SAGITTARIUS'),
            '星座（水瓶座）': (count) => generateConstellation(count, 'AQUARIUS'),
            '球体': (count) => generateSphere(count, 400),
        };

        function loadPresetModel(modelName) {
            const numParticles = Math.min(settings.density, MAX_PARTICLES);
            if (!PRESET_MODELS[modelName]) return;

            // 1. 生成新的位置数据 (x, y, z) 数组
            const newPositions = PRESET_MODELS[modelName](numParticles);
            
            // 2. 将数据填充到 Buffer
            for (let i = 0; i < numParticles; i++) {
                // position (当前位置) 和 initialPosition (聚合/扩散的基准位置) 保持一致
                particlePositions[i * 3 + 0] = initialPositions[i * 3 + 0] = newPositions[i * 3 + 0];
                particlePositions[i * 3 + 1] = initialPositions[i * 3 + 1] = newPositions[i * 3 + 1];
                particlePositions[i * 3 + 2] = initialPositions[i * 3 + 2] = newPositions[i * 3 + 2];
                
                // 随机透明度
                particleOpacities[i] = Math.random() * 0.8 + 0.2; 
            }
            
            // 3. 更新 BufferGeometry
            const geometry = particleSystem.geometry;
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.initialPosition.needsUpdate = true;
            geometry.attributes.pOpacity.needsUpdate = true;
            
            // 4. 更新粒子数量
            updateParticleCount(numParticles);
        }
        
        // --- 粒子形状生成函数 ---
        
        function generateNebula(count, radius) {
            const positions = [];
            for (let i = 0; i < count; i++) {
                // 模拟星云的随机、不规则分布
                const x = (Math.random() - 0.5) * radius * 2;
                const y = (Math.random() - 0.5) * radius * 2;
                const z = (Math.random() - 0.5) * radius * 2;
                
                // 使用 Perlin 噪声或简单随机，加上一个高斯分布，模拟星云的中心密集型
                const d = Math.sqrt(x*x + y*y + z*z);
                if (d < radius * 1.5) {
                    positions.push(x * 0.5 + Math.random() * 200, y * 0.5 + Math.random() * 200, z * 0.5 + Math.random() * 200);
                } else {
                    i--; // 重新生成直到满足条件
                }
            }
            return positions;
        }

        function generateSphere(count, radius) {
            const positions = [];
            for (let i = 0; i < count; i++) {
                // 随机生成球体上的点 (Box-Muller)
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(Math.random() * 2 - 1);
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);

                positions.push(x, y, z);
            }
            return positions;
        }

        // 简化星座生成：使用几个关键点的随机簇
        function generateConstellation(count, name) {
            const positions = [];
            
            // 简化定义星座关键点 (示例数据)
            const keyPoints = {
                'SAGITTARIUS': [
                    [300, 0, 0], [200, 100, 50], [100, -150, 200], [-100, 50, -100], [-300, -50, -50]
                ],
                'AQUARIUS': [
                    [0, 300, 0], [150, 150, 100], [-150, 150, -100], [0, 0, 200], [50, -200, 50]
                ]
            };
            
            const points = keyPoints[name] || keyPoints['SAGITTARIUS'];
            
            for (let i = 0; i < count; i++) {
                // 在随机选择的关键点周围随机分布
                const point = points[Math.floor(Math.random() * points.length)];
                
                const x = point[0] + (Math.random() - 0.5) * 100;
                const y = point[1] + (Math.random() - 0.5) * 100;
                const z = point[2] + (Math.random() - 0.5) * 100;
                
                positions.push(x, y, z);
            }
            return positions;
        }
        
        // --- 自定义手绘功能 ---

        // 记录已绘制粒子的数量
        let customParticleCount = 0; 

        function addCustomParticle(handLandmark) {
            if (customParticleCount >= MAX_PARTICLES) return;

            // 1. 将 MediaPipe 坐标 (0-1 范围) 映射到 Three.js 坐标
            const x = (handLandmark.x - 0.5) * 2 * 600; // 映射到 -600 到 600
            const y = (0.5 - handLandmark.y) * 2 * 600; // 映射到 -600 到 600 (Y轴反转)
            const z = (handLandmark.z) * 1000;         // Z 轴深度 (MediaPipe 的 Z 轴朝向相机)
            
            // 2. 将新的位置添加到 Buffer
            const i = customParticleCount;
            particlePositions[i * 3 + 0] = initialPositions[i * 3 + 0] = x;
            particlePositions[i * 3 + 1] = initialPositions[i * 3 + 1] = y;
            particlePositions[i * 3 + 2] = initialPositions[i * 3 + 2] = z;
            particleOpacities[i] = Math.random() * 0.8 + 0.2;
            
            customParticleCount++;
            
            // 3. 实时更新 BufferGeometry 和粒子数量
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.initialPosition.needsUpdate = true;
            particleSystem.geometry.attributes.pOpacity.needsUpdate = true;
            updateParticleCount(customParticleCount);
        }

        function resetCustomParticles() {
            customParticleCount = 0;
            updateParticleCount(0); // 清空所有粒子
            settings.model = '星云'; // 重置为默认模型
            // 需要重新加载星云模型，但由于在dat.GUI中手动点击，这里可以简单地清空
            // 如果需要切换，则调用 loadPresetModel('星云');
            // ====================================================================
        // === UI (dat.GUI) 初始化 ===
        // ====================================================================

        function initGUI() {
            const gui = new dat.GUI();
            gui.domElement.style.zIndex = '999'; // 确保在最上层
            
            // 预设模型控制
            const modelFolder = gui.addFolder('粒子模型与密度');
            modelFolder.add(settings, 'model', Object.keys(PRESET_MODELS)).name('预设模型').onChange(value => {
                loadPresetModel(value);
                // 切换模型后，自定义粒子数量重置
                customParticleCount = settings.density;
            });
            
            // 粒子密度调节 (只影响下次模型加载，但可以实时限制绘图数量)
            modelFolder.add(settings, 'density', 1000, MAX_PARTICLES).step(100).name('粒子密度').onFinishChange(value => {
                // 实时更新当前粒子的数量 (裁剪或扩展)
                loadPresetModel(settings.model);
            });
            modelFolder.open();

            // 粒子外观控制
            const appearanceFolder = gui.addFolder('外观调节');
            appearanceFolder.addColor(settings, 'particleColor').name('粒子颜色'); // 颜色选择器
            appearanceFolder.add(settings, 'spread', 0.1, 5.0).step(0.1).name('扩散度').listen(); // 实时调节滑杆
            appearanceFolder.open();

            // 手势与绘图控制
            const handFolder = gui.addFolder('手势与绘图');
            handFolder.add(settings, 'handMode', ['单手', '双手']).name('手势模式');
            handFolder.add(settings, 'enableDrawing').name('启用自定义手绘 (捏合)');
            handFolder.add(settings, 'resetCustom').name('重置手绘粒子');
            handFolder.open();

            // UI 最小化功能 (dat.GUI 自带，点击顶部名称即可)
        }
        
        // ====================================================================
        // === 启动流程 ===
        // ====================================================================

        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            initGUI();
            initMediaPipe();
            animate();
        });
        
    </script>
</body>
</html>