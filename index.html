<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>沉浸式手势粒子系统 (MediaPipe + Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 3D 容器 */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* 摄像头画中画 */
        #video-preview {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px;
            border-radius: 12px; border: 2px solid rgba(255,255,255,0.3);
            object-fit: cover; z-index: 10; transform: scaleX(-1); /* 镜像 */
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            background: #000;
        }

        /* UI 面板 */
        #ui-panel {
            position: absolute; top: 20px; left: 20px; width: 280px;
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px; border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            color: white; z-index: 10;
            user-select: none;
            transition: opacity 0.3s;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; letter-spacing: 1px; color: #00ffff; text-shadow: 0 0 10px rgba(0,255,255,0.5); }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; font-size: 12px; margin-bottom: 5px; color: #aaa; }
        
        /* 自定义滑块 */
        input[type="range"] {
            width: 100%; -webkit-appearance: none; background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; background: #00ffff; border-radius: 50%; cursor: pointer;
        }

        /* 按钮组 */
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1);
            color: white; padding: 8px; border-radius: 6px; cursor: pointer;
            transition: all 0.2s; font-size: 12px;
        }
        button:hover { background: rgba(0,255,255,0.2); border-color: #00ffff; }
        button.active { background: #00ffff; color: #000; font-weight: bold; }

        /* 颜色选择器 */
        .color-wrapper { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;}
        input[type="color"] { border: none; width: 40px; height: 25px; cursor: pointer; background: none; }

        /* 绘图层 */
        #draw-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; cursor: crosshair; display: none;
        }
        
        .status { font-size: 10px; color: #aaa; margin-top: 10px; display: flex; align-items: center; gap: 5px;}
        .dot { width: 8px; height: 8px; background: red; border-radius: 50%; display: inline-block; }
        .dot.active { background: #00ff00; box-shadow: 0 0 5px #00ff00; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffff; font-size: 24px; z-index: 100; pointer-events: none;
            text-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>

    <div id="loading">正在加载视觉核心与 AI 模型...</div>

    <div id="canvas-container"></div>
    
    <canvas id="draw-canvas"></canvas>

    <video id="video-preview" playsinline></video>

    <div id="ui-panel">
        <h2>QUANTUM PARTICLES</h2>
        
        <div class="control-group">
            <label>模型预设</label>
            <div class="btn-grid">
                <button onclick="setShape('sphere')" class="active" id="btn-sphere">黑洞球体</button>
                <button onclick="setShape('vortex')" id="btn-vortex">星系漩涡</button>
                <button onclick="setShape('cube')" id="btn-cube">量子立方</button>
                <button onclick="setShape('draw')" id="btn-draw">手绘自定义</button>
            </div>
        </div>

        <div class="color-wrapper">
            <label>粒子颜色</label>
            <input type="color" id="colorPicker" value="#00ffff">
        </div>

        <div class="control-group">
            <label>粒子密度 (Count)</label>
            <input type="range" id="density" min="1000" max="30000" step="1000" value="15000">
        </div>

        <div class="control-group">
            <label>扩散灵敏度 (Spread)</label>
            <input type="range" id="spread" min="0.1" max="5.0" step="0.1" value="2.0">
        </div>

        <div class="status">
            <span class="dot" id="hand-status"></span>
            <span id="status-text">等待摄像头...</span>
        </div>
        <div style="font-size:10px; color:#666; margin-top:5px;">
            操作: 张手=扩散 / 握拳=聚合
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 核心变量 ---
        let scene, camera, renderer;
        let particles, geometry, material;
        let bgParticles;
        let handMesh; // 追踪手的隐形球体
        
        // 状态变量
        let particleCount = 15000;
        let initialPositions = []; // 存储目标形状的坐标
        let currentShape = 'sphere';
        let handPos = new THREE.Vector3(0, 0, 0);
        let isHandDetected = false;
        let isHandOpen = false; // true = 扩散, false = 聚合
        let handStrength = 0; // 0 到 1 平滑过渡
        let baseColor = new THREE.Color(0x00ffff);
        let spreadFactor = 2.0;

        // 绘图相关
        let isDrawing = false;
        let drawPoints = [];
        const drawCanvas = document.getElementById('draw-canvas');
        const drawCtx = drawCanvas.getContext('2d');

        // --- 初始化 Three.js ---
        function init() {
            const container = document.getElementById('canvas-container');
            
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            // 摄像机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 初始化粒子系统
            createParticles();
            createBackgroundStars();

            // 交互事件
            window.addEventListener('resize', onWindowResize, false);
            setupUI();
            setupDrawing();

            // 动画循环
            animate();
            
            // 移除 Loading
            setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 1000);
        }

        // --- 粒子系统逻辑 ---
        function createParticles() {
            if(particles) scene.remove(particles);

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const randomness = new Float32Array(particleCount * 3);
            
            // 初始化位置（在中心）
            for(let i=0; i<particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 50;
                randomness[i] = (Math.random() - 0.5); // 用于噪点运动
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 3));

            // Shader Material 实现发光粒子
            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uColor: { value: baseColor },
                    uHandPos: { value: new THREE.Vector3(0,0,0) },
                    uStrength: { value: 0 }, // 0 = 聚合, 1 = 爆炸
                    uSpread: { value: spreadFactor }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uStrength;
                    uniform float uSpread;
                    uniform vec3 uHandPos;
                    attribute vec3 randomness;
                    varying float vAlpha;
                    
                    void main() {
                        vec3 pos = position;
                        
                        // 基础漂浮动画
                        pos.x += sin(uTime * 0.5 + randomness.y) * 0.2;
                        pos.y += cos(uTime * 0.3 + randomness.x) * 0.2;

                        // 手势互动逻辑
                        float dist = distance(pos, uHandPos);
                        
                        // 如果 uStrength 高 (张手)，根据距离施加排斥力
                        if (uStrength > 0.1) {
                            vec3 dir = normalize(pos - uHandPos);
                            float force = (10.0 * uSpread) / (dist + 0.1); 
                            pos += dir * force * uStrength * 5.0;
                        }

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = (4.0 / -mvPosition.z) * (1.0 + uStrength * 2.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // 距离中心越远稍微暗淡
                        vAlpha = 1.0 - smoothstep(20.0, 60.0, length(pos));
                    }
                `,
                fragmentShader: `
                    uniform vec3 uColor;
                    varying float vAlpha;
                    
                    void main() {
                        // 圆形粒子纹理生成
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        
                        // 辉光效果
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 2.0);

                        gl_FragColor = vec4(uColor, glow * vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // 生成目标形状数据
            updateTargetShape();
        }

        // --- 形状生成算法 ---
        function updateTargetShape() {
            initialPositions = [];
            const radius = 10;
            
            for(let i=0; i<particleCount; i++) {
                let x, y, z;

                if(currentShape === 'sphere') {
                    // 黑洞/球体
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = radius * Math.cbrt(Math.random()); 
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } 
                else if (currentShape === 'cube') {
                    // 立方体
                    x = (Math.random() - 0.5) * radius * 1.5;
                    y = (Math.random() - 0.5) * radius * 1.5;
                    z = (Math.random() - 0.5) * radius * 1.5;
                }
                else if (currentShape === 'vortex') {
                    // 漩涡
                    const angle = i * 0.01;
                    const r = (i / particleCount) * radius * 2;
                    x = r * Math.cos(angle);
                    y = (Math.random() - 0.5) * 2; // 扁平
                    z = r * Math.sin(angle);
                }
                else if (currentShape === 'draw') {
                    // 自定义绘画
                    if (drawPoints.length > 0) {
                        const p = drawPoints[i % drawPoints.length];
                        x = p.x;
                        y = p.y;
                        z = (Math.random() - 0.5) * 2;
                    } else {
                        // 默认圆圈
                         const theta = Math.random() * Math.PI * 2;
                         x = Math.cos(theta) * 5;
                         y = Math.sin(theta) * 5;
                         z = 0;
                    }
                }

                initialPositions.push(x, y, z);
            }
        }

        // --- 背景星空 ---
        function createBackgroundStars() {
            const bgGeo = new THREE.BufferGeometry();
            const bgCount = 2000;
            const bgPos = new Float32Array(bgCount * 3);
            
            for(let i=0; i<bgCount*3; i++) {
                bgPos[i] = (Math.random() - 0.5) * 200; // 广阔空间
            }
            bgGeo.setAttribute('position', new THREE.BufferAttribute(bgPos, 3));
            
            const bgMat = new THREE.PointsMaterial({
                color: 0x888888,
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });
            
            bgParticles = new THREE.Points(bgGeo, bgMat);
            scene.add(bgParticles);
        }

        // --- MediaPipe Hands 配置 ---
        function setupMediaPipe() {
            const videoElement = document.getElementById('video-preview');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandsResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 320,
                height: 240
            });
            cameraUtils.start();
        }

        function onHandsResults(results) {
            const statusDot = document.getElementById('hand-status');
            const statusText = document.getElementById('status-text');

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                statusDot.classList.add('active');
                
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. 计算手部中心在 3D 空间的位置
                // MediaPipe x,y 是 0-1, 我们映射到 Three.js 视口坐标
                // 注意：Webcam 是镜像的，x 需要翻转
                const x = (0.5 - landmarks[9].x) * 40; // 9 是中指根部
                const y = (0.5 - landmarks[9].y) * 25; 
                
                // 平滑移动
                handPos.lerp(new THREE.Vector3(x, y, 0), 0.1);

                // 2. 检测手势张合
                // 计算拇指指尖(4)到食指指尖(8) + 中指指尖(12)的平均距离
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const wrist = landmarks[0];

                const distOpen = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
                
                // 简单阈值：指尖距离手腕远 = 张开，近 = 握拳
                // 这里的逻辑：如果手掌张开，产生排斥力
                // 我们可以用一种更直观的：食指指尖和拇指指尖的距离
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

                if (pinchDist > 0.15) {
                    isHandOpen = true; // 张开
                    statusText.innerText = "手势: 张开 (扩散)";
                } else {
                    isHandOpen = false; // 闭合/捏合
                    statusText.innerText = "手势: 捏合 (聚合)";
                }

            } else {
                isHandDetected = false;
                statusDot.classList.remove('active');
                statusText.innerText = "未检测到手部";
                // 没手的时候，默认稍微聚合
                isHandOpen = false;
            }
        }

        // --- 绘图功能 ---
        function setupDrawing() {
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;

            // 转换屏幕坐标到 3D 坐标
            function get3DPos(clientX, clientY) {
                const vec = new THREE.Vector3();
                const pos = new THREE.Vector3();
                
                vec.set(
                    (clientX / window.innerWidth) * 2 - 1,
                    -(clientY / window.innerHeight) * 2 + 1,
                    0.5
                );
                
                vec.unproject(camera);
                vec.sub(camera.position).normalize();
                
                const distance = -camera.position.z / vec.z;
                pos.copy(camera.position).add(vec.multiplyScalar(distance));
                return pos;
            }

            drawCanvas.addEventListener('mousedown', e => {
                isDrawing = true;
                drawPoints = []; // 清空旧图
                drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
                drawCtx.beginPath();
                drawCtx.moveTo(e.clientX, e.clientY);
                drawCtx.strokeStyle = '#00ffff';
                drawCtx.lineWidth = 3;
            });

            drawCanvas.addEventListener('mousemove', e => {
                if(!isDrawing) return;
                drawCtx.lineTo(e.clientX, e.clientY);
                drawCtx.stroke();
                
                // 记录 3D 点
                const p3d = get3DPos(e.clientX, e.clientY);
                drawPoints.push(p3d);
            });

            drawCanvas.addEventListener('mouseup', () => {
                isDrawing = false;
                // 绘图结束，应用形状
                updateTargetShape();
                // 隐藏 Canvas
                toggleDrawMode(false);
                // 切换回 3D 交互
                document.getElementById('btn-draw').classList.add('active');
            });
        }

        function toggleDrawMode(active) {
            const canvas = document.getElementById('draw-canvas');
            const btns = document.querySelectorAll('.btn-grid button');
            btns.forEach(b => b.classList.remove('active'));

            if(active) {
                canvas.style.display = 'block';
                document.getElementById('status-text').innerText = "请在屏幕上绘制图案...";
                currentShape = 'draw';
            } else {
                canvas.style.display = 'none';
            }
        }

        // --- UI 控制 ---
        function setShape(shape) {
            currentShape = shape;
            if (shape === 'draw') {
                toggleDrawMode(true);
            } else {
                toggleDrawMode(false);
                document.getElementById(`btn-${shape}`).classList.add('active');
                updateTargetShape();
            }
        }

        function setupUI() {
            // 颜色
            document.getElementById('colorPicker').addEventListener('input', (e) => {
                baseColor.set(e.target.value);
                if(material) material.uniforms.uColor.value = baseColor;
            });

            // 密度 (需要重新生成粒子)
            document.getElementById('density').addEventListener('change', (e) => {
                particleCount = parseInt(e.target.value);
                createParticles();
            });

            // 扩散
            document.getElementById('spread').addEventListener('input', (e) => {
                spreadFactor = parseFloat(e.target.value);
                if(material) material.uniforms.uSpread.value = spreadFactor;
            });
        }

        // --- 渲染循环 ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;

            if (material) {
                material.uniforms.uTime.value = time;
                material.uniforms.uHandPos.value = handPos;

                // 平滑过渡手势强度
                let targetStrength = isHandOpen ? 1.0 : 0.0;
                // 如果没检测到手，自动变为 0 (聚合)
                if (!isHandDetected) targetStrength = 0.0;
                
                handStrength += (targetStrength - handStrength) * 0.1;
                material.uniforms.uStrength.value = handStrength;

                // 物理模拟：将粒子拉向目标形状 (CPU 端计算位置插值)
                // 为了性能，我们只在 CPU 端做简单的引力，复杂的爆炸在 Shader
                // 如果手张开 (uStrength 高)，Shader 会处理偏移
                // 如果手闭合，我们需要粒子回到 initialPositions
                
                const positions = geometry.attributes.position.array;
                
                // 只有在手闭合（聚合模式）时，我们才强制把粒子拉回形状
                // 为了视觉效果，我们始终让粒子在其目标位置附近游动
                
                // 性能优化：每帧只更新部分或者利用 Shader 
                // 这里我们采用一种混合法：CPU 慢慢插值回原位，GPU 处理手部排斥
                if (handStrength < 0.5) {
                    for(let i=0; i<particleCount; i++) {
                        const ix = i * 3;
                        const iy = i * 3 + 1;
                        const iz = i * 3 + 2;

                        // 简单的 Lerp 回归
                        positions[ix] += (initialPositions[ix] - positions[ix]) * 0.05;
                        positions[iy] += (initialPositions[iy] - positions[iy]) * 0.05;
                        positions[iz] += (initialPositions[iz] - positions[iz]) * 0.05;
                    }
                    geometry.attributes.position.needsUpdate = true;
                }
            }

            // 背景旋转
            if(bgParticles) {
                bgParticles.rotation.y = time * 0.05;
                bgParticles.rotation.x = time * 0.02;
            }

            // 整个场景跟随鼠标微动（增加空间感）
            scene.rotation.y = (handPos.x / 50) * 0.2; 
            scene.rotation.x = -(handPos.y / 50) * 0.2;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            drawCanvas.width = window.innerWidth;
            drawCanvas.height = window.innerHeight;
        }

        // 启动
        init();
        setupMediaPipe();

    </script>
</body>
</html>
