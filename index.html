<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>WebAR æ‰‹åŠ¿éš”ç©ºå†™å­—ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #222; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        /* è§†é¢‘å±‚éšè—æˆ–ç½®åº•ï¼Œè¿™é‡Œåè½¬é•œåƒè®©æ“ä½œæ›´è‡ªç„¶ */
        video { position: absolute; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0.5; }
        /* ç”»å¸ƒå±‚è¦†ç›–åœ¨ä¸Šé¢ */
        canvas { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; pointer-events: none; z-index: 10;
        }
        .instruction {
            position: absolute; top: 10px; left: 10px; color: #00ffcc;
            background: rgba(0,0,0,0.6); padding: 10px; border-radius: 8px;
            pointer-events: none; z-index: 5; font-size: 14px; line-height: 1.5;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="loading">æ­£åœ¨åŠ è½½æ¨¡å‹ï¼Œè¯·ç¨å€™...</div>
    <div class="instruction">
        <b>æ“ä½œæŒ‡å—ï¼š</b><br>
        ğŸ– <b>å¼ å¼€æ‰‹æŒ</b>ï¼šæ‰“å¼€/å…³é—­ èœå•<br>
        â˜ <b>é£ŸæŒ‡</b>ï¼šåœ¨èœå•ä¸­é€‰æ‹©åŠŸèƒ½<br>
        ğŸ‘Œ <b>æ‹‡æŒ‡+é£ŸæŒ‡æåˆ</b>ï¼šå†™å­—<br>
        âœŒ <b>å‰ªåˆ€æ‰‹(é£ŸæŒ‡+ä¸­æŒ‡)</b>ï¼šé›ªèŠ±æ¶ˆæ•£æ¸…å±<br>
        â˜ + â˜ <b>åŒæ‰‹é£ŸæŒ‡</b>ï¼šç¼©æ”¾ç”»å¸ƒ
    </div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    // --- çŠ¶æ€ç®¡ç† ---
    let strokes = []; // å­˜å‚¨ç¬”ç”»: [ {points: [{x,y}], color, size, isEraser} ]
    let currentStroke = null;
    let particles = []; // é›ªèŠ±ç²’å­
    
    // ç”»ç¬”è®¾ç½®
    let settings = {
        color: '#00FF00',
        size: 5,
        isEraser: false,
        zoom: 1.0,
        offset: { x: 0, y: 0 } // ç”¨äºå¹³ç§»ï¼ˆè™½ç„¶éœ€æ±‚ä¸»è¦æäº†ç¼©æ”¾ï¼Œä½†ç¼©æ”¾é€šå¸¸é…åˆå¹³ç§»ï¼‰
    };

    // UI çŠ¶æ€
    let uiState = {
        isOpen: false,
        lastToggleTime: 0,
        buttons: []
    };
    
    // åŒæ‰‹ç¼©æ”¾è¾…åŠ©å˜é‡
    let lastPinchDist = null;

    // åˆå§‹åŒ– UI æŒ‰é’®
    function initButtons() {
        const w = canvasElement.width;
        const h = canvasElement.height;
        const btnW = 80;
        const btnH = 50;
        const startX = w / 2 - 200;
        const startY = h / 2 - 150;

        uiState.buttons = [
            { type: 'tool', label: 'âœï¸ ç¬”', val: 'pen', x: startX, y: startY, w: btnW, h: btnH },
            { type: 'tool', label: 'ğŸ§½ æ“¦', val: 'eraser', x: startX + 100, y: startY, w: btnW, h: btnH },
            
            { type: 'color', label: 'ğŸ”´', val: '#FF0000', x: startX, y: startY + 70, w: btnW, h: btnH },
            { type: 'color', label: 'ğŸŸ¢', val: '#00FF00', x: startX + 100, y: startY + 70, w: btnW, h: btnH },
            { type: 'color', label: 'ğŸ”µ', val: '#0000FF', x: startX + 200, y: startY + 70, w: btnW, h: btnH },
            { type: 'color', label: 'ğŸŸ¡', val: '#FFFF00', x: startX + 300, y: startY + 70, w: btnW, h: btnH },

            { type: 'size', label: 'ç»†', val: 2, x: startX, y: startY + 140, w: btnW, h: btnH },
            { type: 'size', label: 'ä¸­', val: 5, x: startX + 100, y: startY + 140, w: btnW, h: btnH },
            { type: 'size', label: 'ç²—', val: 12, x: startX + 200, y: startY + 140, w: btnW, h: btnH },
        ];
    }

    // --- å‡ ä½•ä¸è¾…åŠ©å‡½æ•° ---

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        initButtons();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function distance(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // åæ ‡è½¬æ¢ï¼šMediaPipe (0-1) -> Canvas åƒç´ 
    function toPixel(lm) {
        return { x: lm.x * canvasElement.width, y: lm.y * canvasElement.height };
    }

    // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---

    function detectGestures(landmarks) {
        // landmarks: 0-20 (MediaPipe Hands Keypoints)
        // 4: Thumb Tip, 8: Index Tip, 12: Middle Tip, 16: Ring Tip, 20: Pinky Tip
        // 0: Wrist

        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        const wrist = landmarks[0];

        // 1. åˆ¤æ–­æåˆ (å†™å­—): æ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»æè¿‘
        const pinchDist = distance(thumbTip, indexTip);
        const isPinching = pinchDist < 0.05;

        // 2. åˆ¤æ–­æ‰‹æŒå¼ å¼€ (èœå•): æ‰€æœ‰æ‰‹æŒ‡ä¼¸ç›´
        // ç®€å•é€»è¾‘ï¼šæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦» > æŒ‡å…³èŠ‚åˆ°æ‰‹è…•çš„è·ç¦»
        function isFingerOpen(tipIdx, pipIdx) {
            return distance(landmarks[tipIdx], wrist) > distance(landmarks[pipIdx], wrist);
        }
        const isPalmOpen = isFingerOpen(8, 6) && isFingerOpen(12, 10) && isFingerOpen(16, 14) && isFingerOpen(20, 18) && !isPinching;

        // 3. åˆ¤æ–­å‰ªåˆ€æ‰‹ (æ¸…å±): é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²
        const isVictory = isFingerOpen(8, 6) && isFingerOpen(12, 10) && 
                          !isFingerOpen(16, 14) && !isFingerOpen(20, 18);

        // 4. åˆ¤æ–­å•æŒ‡æŒ‡å‘ (é€‰æ‹©èœå•): åªæœ‰é£ŸæŒ‡ä¼¸ç›´
        const isPointing = isFingerOpen(8, 6) && !isFingerOpen(12, 10) && !isFingerOpen(16, 14) && !isFingerOpen(20, 18);

        return { isPinching, isPalmOpen, isVictory, isPointing };
    }

    // --- ç²’å­ç³»ç»Ÿ (é›ªèŠ±æ•ˆæœ) ---
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.vx = (Math.random() - 0.5) * 4;
            this.vy = (Math.random() * 2) + 1; // å‘ä¸‹é£˜
            this.life = 1.0;
            this.decay = Math.random() * 0.02 + 0.005;
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vx += Math.sin(this.y * 0.05) * 0.1; // é£˜åŠ¨æ•ˆæœ
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, 3, 3);
            ctx.globalAlpha = 1.0;
        }
    }

    function triggerSnow() {
        if (strokes.length === 0) return;
        
        // å°†æ‰€æœ‰ç¬”è§¦è½¬åŒ–ä¸ºç²’å­
        strokes.forEach(stroke => {
            // é‡‡æ ·ç‚¹ä»¥å‡å°‘ç²’å­æ•°é‡ï¼Œé¿å…å¡é¡¿
            for (let i = 0; i < stroke.points.length; i += 2) {
                const p = stroke.points[i];
                // åº”ç”¨å½“å‰çš„ç¼©æ”¾å˜æ¢ä½ç½®
                const finalX = p.x * settings.zoom + settings.offset.x;
                const finalY = p.y * settings.zoom + settings.offset.y;
                particles.push(new Particle(finalX, finalY, stroke.color));
            }
        });
        strokes = []; // æ¸…ç©ºç¬”è¿¹
        currentStroke = null;
    }

    // --- ä¸»å¾ªç¯ä¸ç»˜åˆ¶ ---

    function onResults(results) {
        loadingDiv.style.display = 'none';
        
        // æ¸…é™¤ç”»å¸ƒ
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // ç»˜åˆ¶æ£€æµ‹åˆ°çš„æ‰‹ (å¯é€‰ï¼Œè¾…åŠ©æ˜¾ç¤º)
        /*
        if (results.multiHandLandmarks) {
            for (const landmarks of results.multiHandLandmarks) {
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1});
            }
        }
        */

        const hands = results.multiHandLandmarks;

        // 1. åŒæ‰‹é€»è¾‘ï¼šç¼©æ”¾
        if (hands && hands.length === 2) {
            const h1 = hands[0];
            const h2 = hands[1];
            
            // ç®€å•åˆ¤æ–­ï¼šå¦‚æœä¸¤ä¸ªæ‰‹éƒ½æ˜¯é£ŸæŒ‡ä¼¸å‡ºï¼Œåˆ™è¿›è¡Œç¼©æ”¾
            // è¿™é‡Œä¸ºäº†ä½“éªŒæµç•…ï¼Œç›´æ¥åˆ¤æ–­ä¸¤ä¸ªé£ŸæŒ‡å°–çš„è·ç¦»
            const idx1 = toPixel(h1[8]);
            const idx2 = toPixel(h2[8]);
            const dist = distance({x: idx1.x/canvasElement.width, y: idx1.y/canvasElement.height}, 
                                  {x: idx2.x/canvasElement.width, y: idx2.y/canvasElement.height});

            if (lastPinchDist !== null) {
                const delta = dist - lastPinchDist;
                settings.zoom += delta * 2; 
                settings.zoom = Math.max(0.1, Math.min(settings.zoom, 5.0)); // é™åˆ¶ç¼©æ”¾èŒƒå›´
                
                // ç»˜åˆ¶æŒ‡ç¤ºçº¿
                canvasCtx.strokeStyle = 'white';
                canvasCtx.beginPath();
                canvasCtx.moveTo(idx1.x, idx1.y);
                canvasCtx.lineTo(idx2.x, idx2.y);
                canvasCtx.stroke();
            }
            lastPinchDist = dist;
            
            // åŒæ‰‹æ—¶ä¸è¿›è¡Œå…¶ä»–æ“ä½œ
            renderStrokes();
            renderParticles();
            canvasCtx.restore();
            return; 
        } else {
            lastPinchDist = null;
        }

        // 2. å•æ‰‹é€»è¾‘
        if (hands && hands.length > 0) {
            // åªå–ç¬¬ä¸€åªæ‰‹ä½œä¸ºä¸»æ§æ‰‹
            const landmarks = hands[0];
            const gestures = detectGestures(landmarks);
            const indexTipPx = toPixel(landmarks[8]);

            // --- çŠ¶æ€æœº ---

            // A. é›ªèŠ±æ¶ˆæ•£ (èƒœåˆ©æ‰‹åŠ¿)
            if (gestures.isVictory && particles.length === 0 && strokes.length > 0) {
                triggerSnow();
            }

            // B. èœå•å¼€å…³ (æ‰‹æŒ)
            const now = Date.now();
            if (gestures.isPalmOpen && (now - uiState.lastToggleTime > 1000)) {
                uiState.isOpen = !uiState.isOpen;
                uiState.lastToggleTime = 0;
                // é‡ç½®å½“å‰ç¬”ç”»ï¼Œé˜²æ­¢æ„å¤–è¿çº¿
                currentStroke = null;
            }

            // C. èœå•äº¤äº’ (èœå•å¼€å¯ + é£ŸæŒ‡æŒ‡å‘)
            if (uiState.isOpen) {
                drawMenu(indexTipPx, gestures.isPointing);
            } 
            // D. å†™å­— (èœå•å…³é—­ + æåˆ)
            else if (gestures.isPinching) {
                // è®¡ç®—ç›¸å¯¹äºç¼©æ”¾å’Œåç§»çš„åŸå§‹åæ ‡
                // Inverse transform: rawX = (screenX - offsetX) / zoom
                const rawX = (indexTipPx.x - settings.offset.x) / settings.zoom;
                const rawY = (indexTipPx.y - settings.offset.y) / settings.zoom;

                if (!currentStroke) {
                    currentStroke = {
                        points: [{x: rawX, y: rawY}],
                        color: settings.isEraser ? 'rgba(0,0,0,1)' : settings.color, // æ©¡çš®æ“¦å®è´¨æ˜¯åˆæˆæ“ä½œï¼Œè¿™é‡Œé¢œè‰²å ä½
                        size: settings.size,
                        isEraser: settings.isEraser
                    };
                    strokes.push(currentStroke);
                } else {
                    currentStroke.points.push({x: rawX, y: rawY});
                }
                
                // ç»˜åˆ¶ç¬”å°–æŒ‡ç¤ºå™¨
                canvasCtx.beginPath();
                canvasCtx.arc(indexTipPx.x, indexTipPx.y, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = settings.color;
                canvasCtx.fill();
            } else {
                currentStroke = null;
                // ç»˜åˆ¶æ‚¬æµ®å…‰æ ‡
                canvasCtx.beginPath();
                canvasCtx.arc(indexTipPx.x, indexTipPx.y, 3, 0, 2 * Math.PI);
                canvasCtx.fillStyle = 'white';
                canvasCtx.fill();
            }
        }

        renderStrokes();
        renderParticles();
        
        canvasCtx.restore();
    }

    // --- æ¸²æŸ“å‡½æ•° ---

    function renderStrokes() {
        canvasCtx.save();
        // åº”ç”¨å…¨å±€å˜æ¢
        canvasCtx.translate(settings.offset.x, settings.offset.y);
        canvasCtx.scale(settings.zoom, settings.zoom);
        
        canvasCtx.lineCap = 'round';
        canvasCtx.lineJoin = 'round';

        strokes.forEach(stroke => {
            if (stroke.points.length < 2) return;

            canvasCtx.beginPath();
            canvasCtx.lineWidth = stroke.size;
            
            if (stroke.isEraser) {
                canvasCtx.globalCompositeOperation = 'destination-out';
                canvasCtx.strokeStyle = 'rgba(0,0,0,1)'; 
            } else {
                canvasCtx.globalCompositeOperation = 'source-over';
                canvasCtx.strokeStyle = stroke.color;
            }

            canvasCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
            for (let i = 1; i < stroke.points.length; i++) {
                // äºŒæ¬¡è´å¡å°”æ›²çº¿å¹³æ»‘
                // const midPoint = midPointBtw(stroke.points[i-1], stroke.points[i]);
                // canvasCtx.quadraticCurveTo(stroke.points[i-1].x, stroke.points[i-1].y, midPoint.x, midPoint.y);
                canvasCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
            }
            canvasCtx.stroke();
        });
        canvasCtx.restore();
    }

    function renderParticles() {
        if (particles.length > 0) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw(canvasCtx);
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
    }

    function drawMenu(pointerPx, isPointing) {
        // åŠé€æ˜èƒŒæ™¯
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
        
        canvasCtx.font = "20px Arial";
        canvasCtx.textAlign = "center";
        canvasCtx.textBaseline = "middle";

        uiState.buttons.forEach(btn => {
            let isHover = false;
            // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
            if (isPointing && 
                pointerPx.x > btn.x && pointerPx.x < btn.x + btn.w &&
                pointerPx.y > btn.y && pointerPx.y < btn.y + btn.h) {
                isHover = true;
                
                // è§¦å‘é€‰æ‹©
                if (btn.type === 'tool') {
                    settings.isEraser = (btn.val === 'eraser');
                } else if (btn.type === 'color') {
                    settings.color = btn.val;
                    settings.isEraser = false;
                } else if (btn.type === 'size') {
                    settings.size = btn.val;
                }
            }

            // ç»˜åˆ¶æŒ‰é’®èƒŒæ™¯
            let isActive = false;
            if (btn.type === 'tool') isActive = (settings.isEraser && btn.val === 'eraser') || (!settings.isEraser && btn.val === 'pen');
            if (btn.type === 'color') isActive = (settings.color === btn.val && !settings.isEraser);
            if (btn.type === 'size') isActive = (settings.size === btn.val);

            if (isHover) canvasCtx.fillStyle = '#666';
            else if (isActive) canvasCtx.fillStyle = '#00aa00'; // é€‰ä¸­çŠ¶æ€
            else canvasCtx.fillStyle = '#333';

            canvasCtx.fillRect(btn.x, btn.y, btn.w, btn.h);
            canvasCtx.strokeStyle = 'white';
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeRect(btn.x, btn.y, btn.w, btn.h);

            // ç»˜åˆ¶æ–‡å­—
            canvasCtx.fillStyle = 'white';
            if(btn.type === 'color') canvasCtx.fillStyle = btn.val; // é¢œè‰²æŒ‰é’®æ–‡å­—ç›´æ¥ç”¨é¢œè‰²
            canvasCtx.fillText(btn.label, btn.x + btn.w/2, btn.y + btn.h/2);
        });

        // ç»˜åˆ¶å…‰æ ‡
        canvasCtx.beginPath();
        canvasCtx.arc(pointerPx.x, pointerPx.y, 8, 0, 2*Math.PI);
        canvasCtx.fillStyle = isPointing ? 'cyan' : 'red'; // æŒ‡å‘æ—¶å˜è‰²
        canvasCtx.fill();
    }


    // --- MediaPipe åˆå§‹åŒ– ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7, // æé«˜ç½®ä¿¡åº¦ä»¥å‡å°‘æŠ–åŠ¨
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();

</script>
</body>
</html>